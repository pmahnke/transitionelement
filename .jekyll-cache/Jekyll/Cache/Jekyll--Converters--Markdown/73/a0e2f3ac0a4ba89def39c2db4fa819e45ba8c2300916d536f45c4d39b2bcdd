I"’<p>At some point, you have been sent an HTML email with images that are still on the server. Most email clients will not download the images automatically, unless the sender is in your address book or been white-listed somehow. You either get:</p>

<h3 id="an-email-with-no-images-just-empty-boxes">An email with no images, just empty boxes</h3>

<p><img src="/assets/images/Screen%20shot%202010-12-03%20at%2020.17.05.png" width="615" height="98" class="photo center" alt="email, no images" /></p>

<p>or,</p>

<h3 id="an-email-with-no-images-empty-boxes-and-a-message-asking-you-if-you-want-to-download-them">An email with no images, empty boxes and a message asking you if you want to download them.</h3>

<p><img src="/assets/images/Screen%20shot%202010-12-03%20at%2020.19.54.png" width="417" height="45" class="photo center" alt="email, download first" /></p>

<p>This is for good reason, nasty marketers can embedded tracking codes and who knows what else (joke)‚Ä¶</p>

<p>Of course, the real solution to this is, <em>send plain text or rich text emails</em>; however, I realise there are times when an HTML email is the only think that will make the boss and the design team happy. Specially for the company Christmas email.</p>

<p>So I have ended up coding a web form that allows people add the To:, From:, Subject: and a personal message to our email, but it needs to send our nice corporate image too.</p>

<p><img src="/assets/images/xmas_image_2010.gif" width="600" height="400" class="photo center" alt=" Scholastic Xmas emailer 2010" /></p>

<p>Using <a href="http://search.cpan.org/~rjbs/MIME-Lite-3.027/lib/MIME/Lite.pm">MIME::Lite</a>, you can easily send these images with a <a href="http://en.wikipedia.org/wiki/MIME#Mixed">multipart/mixed</a> email. Basically, you make the image source point to a file ‚Äúcid:&lt;filename&gt;‚Äù and then attach that &lt;filename&gt;. However, I figured, you might get a lot of image files in your HTML email and some might not even be local.</p>

<p><em>What a pain it would be to hand code these up every time!</em></p>

<p>So I wrote a script that:</p>

<ol>
  <li>parses the HTML looking for &lt;img tags</li>
  <li>if it finds one, it checks if the file is local or remote
    <ol>
      <li>if it is remote, it <em>wget</em> the file and makes it a local one (you have to delete these later)</li>
    </ol>
  </li>
  <li>then it turns the source of the image to the correct new one &lt;img src=‚Äùcid:</li>
  <li>finally, it attaches the file, using <a href="http://en.wikipedia.org/wiki/Base64">base64</a></li>
</ol>

<p>Now this will work for any HTML email I send, not just the Christmas card. The benefits are:</p>

<ul>
  <li>less chance of the email being flagged as SPAM</li>
  <li>better chance someone will see the HTML email</li>
  <li>happier boss and design people</li>
</ul>

<p>Here is some code‚Ä¶</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;
################################################################################
sub email {

    # Create the multipart "container":

    MIME::Lite-&gt;send("sendmail", "/usr/sbin/sendmail -t -oi -oem &gt;&amp; /dev/null");
    $msg = MIME::Lite-&gt;new(
       From    =&gt;$FORM{'from'},
       Cc      =&gt;$FORM{'cc'},
       Bcc     =&gt;$FORM{'bcc'},
       Subject =&gt;$FORM{'subject'},
       Disposition =&gt; 'inline',
       Type    =&gt;'multipart/related'
       );
    $msg-&gt;attr("content-type.charset" =&gt; "UTF-8");


    # parse the images in the HTML
    my $html = &amp;parseHTMLinlineImages($FORM{'html'});

    # convert to utf8, not a requirement for everyone....
    $html = encode("utf8", $html);

    # Add the html itself:
    $msg-&gt;attach(
       Type     =&gt;'text/html',
       Data     =&gt; $html,
       );

    $msg-&gt;scrub(['content-disposition', 'content-length']);
    $msg-&gt;send;

    return();
}

################################################################################
sub parseHTMLinlineImages {

    # input 0 - html

    my ($in, $out);
    my @lines = split (/\n/, $_[0]);

    foreach (@lines) {

        if (/&lt;img/) {

            # in image tag
            if (/src="(.[^"]*)"/i) {

      # deal with the image itself
      my $img = &amp;prepAttachImg($1);

      # change the html to reference the attached image
      # e.g. &lt;img src="cid: ... " .../&gt;
      s/$1/cid:$img/g;
            }
        }
        $out .= "$_\n";
    }
    return($out);
}

################################################################################
sub prepAttachImg {

    # deal with physical images and make them into MIME::Lite attachments

    my $/assets/images/ = $_[0];
    my ($filename, $fileloc) = "";

    $filename = basename($/assets/images/); # using File::Basename to get the file name only

    # see if local or not
    if ($/assets/images/ =~ /http/) {

        # not local, so wget the file, etc...
        $fileloc = "/tmp/".$filename; # where to save the file

        # test to see if we already have it
        if (!-e "$fileloc") {

            # no it isn't already in tmp, so wget it
            `/usr/bin/wget --quiet --output-document=$fileloc $/assets/images/`;

        }

    } else {

        # test if it is actually where we think it should be on the server
        if (!-e "$/assets/images/") {

            # file not found
            $mesg .= qq |file not found&lt;br /&gt;$/assets/images/ $filename|;
            &amp;printERROR();
            exit;

        } else {

            # is it on the srever where it says, so don't even move it...
            $fileloc = $/assets/images/;

        }
    }

    # set the mime type for MIME::Lite
    my $mimetype = $1 if ($/assets/images/ =~ /\.(gif|jpg|png)/);
    $mimetype = "jpeg" if ($mimetype =~ /jpg/i);

    # attach it to the already open $msg
    $msg-&gt;attach(
        Type =&gt; 'image/'.$mimetype,
        Id   =&gt; $filename,
        Path =&gt; $fileloc,
    );

    return($filename); # return the pathless filename

}
&lt;/code&gt;
</code></pre></div></div>
:ET